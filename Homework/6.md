## Домашнее задание шестой недели обучения

#### Задание на 9 балов

- Поднять в окружении 2 инстанса БД для `order-service`
- Сконфигурировать `service-discovery` для новых инстансов (`orders-1, buckets 0-3; orders-2, buckets 4-7`)
- Реализовать функцию для определения бакета по ключу
- Настроить `connectionFactory` на работу с шардированной базой через `service-discovery`
- Переделать мигратор на работу с шардированной базой
- Выполнить миграцию на шардированный кластер (по бакетам)
- Перевести работу сервиса на шардированную базу

#### Задание на 10 баллов

- Реализовать индексный поиск для получения заказов не по ключу шардирования (согласно контрактам)
- Транзакционность запросов на изменение данных, по которым существует глобальный индекс, обеспечивать не требуется (выходит за рамки задания)

### FAQ

##### Как быть с ручками, которые ищут не по ключу с пагинацией и т.п.?

Для выполнения задания достаточно, чтобы вы перебирали все заказы из всех бакетов. Но для ендпоинтов, осуществляющих поиск не по ключу шардирования, можно реализовать глобальный индекс (*задание на 10 баллов*). Подсказка -  в индекс можно добавить необходимые поля для фильтрации

##### Как быть с другими сущностями в нашей БД — склады/регионы?

Так как это справочники, то их состав допустимо просто копировать во все шарды и держать в каждом шарде копию. Вы можете шардировать также и их, но не забудьте снять `foreign key constraint`, если они у вас были.

##### Как быть с транзакционностью?

Для выполнения задания с алмазиком при реализации глобального индекса НЕ требуется, чтобы его обновление было выполнено транзационно с вставкой/изменением основной сущности, т.к. в общем случае оно будет выполняться на другом шарде и потребует распределенной транзакции. При этом, следует сохранить транзакционность сохранения самих сущностей в рамках одного запроса

##### Как быть с множественной вставкой?

Реализация вставки массива объектов остается на ваш выбор. Для использования конструкции `unnest` допускается создавать пользовательский тип в базе только в схеме `public` (через миграции)

#### Критерии приемки:

1. Присутствуют базы данных `orders-1` и `orders-2`
2. В базе `orders-1` находятся схемы `bucket_0, bucket_1, bucket_2, bucket_3`
3. В базе orders-2 находятся схемы `bucket_4, bucket_5, bucket_6, bucket_7`
4. В каждую схему `bucket_N` смигрирована структура БД
5. Реализован `IShardingRule`, выполняющий преобразование ключа шардирования в номер бакета
6. Реализован `ShardConnectionFactory`, создающий подключения к нужному инстансу БД на основе ключа
7. Репозиторий переведен на использование `ShardConnectionFactory`
8. Все API работают как и прежде.

#### Для задания на 10 баллов:

1. Создана индексная таблица для поиска заказов не по ключу шардирования. Количество индексов определяется контрактами на поиск заказов, но требуется реализовать хотя бы один
2. При вставке/обновлении, затрагивающем индексное поле/удалении заказа, также обновляется индексная таблица/ы (без транзакции)
3. Поиск заказов не по ключу шардирования производится через индексную таблицу/ы, а не по всем бакетам

#### Дедлайн: 
13 апреля, 23:59 (сдача) / 16 апреля, 23:59 (проверка)